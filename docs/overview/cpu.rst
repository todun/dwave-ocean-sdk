.. _using_cpu:

=================
Classical Solvers
=================

You might use a classical solver while developing your code or on a small version of
your problem to verify your code.
To solve a problem classically on your local machine, you configure a classical solver,
either one of those included in the Ocean tools or your own.

Examples
~~~~~~~~

Among several samplers provided in the :doc:`dimod </docs_dimod/sdk_index>`
tool for testing your code locally, is the :code:`ExactSolver()` that calculates the energy of all
possible samples for a given problem. Such a sampler can solve a small three-variable
problem like the AND gate of the :ref:`formulating_bqm` section.

.. code-block:: python

    >>> from dimod.reference.samplers import ExactSolver
    >>> sampler = ExactSolver()
    >>> response = sampler.sample(bqm)    # doctest: +SKIP
    >>> for datum in response.data(['sample', 'energy']):     # doctest: +SKIP
    ...    print(datum.sample, datum.energy)
    ...
    {'x1': 0, 'x2': 0, 'y1': 0} -1.5
    {'x1': 1, 'x2': 0, 'y1': 0} -1.5
    {'x1': 0, 'x2': 1, 'y1': 0} -1.5
    {'x1': 1, 'x2': 1, 'y1': 1} -1.5
    {'x1': 1, 'x2': 1, 'y1': 0} 0.5
    {'x1': 0, 'x2': 1, 'y1': 1} 0.5
    {'x1': 1, 'x2': 0, 'y1': 1} 0.5
    {'x1': 0, 'x2': 0, 'y1': 1} 4.5

Note that the first four samples are the valid states of the AND gate and have
lower values than the second four, which represent invalid states.

If you use a classical solver running locally on your CPU, a single sample might provide
the optimal solution.

This example solves a two-variable problem using the :doc:`dwave_neal </docs_neal/sdk_index>`
simulated annealing sampler. The two samples requested and generated by this classical
solver on your local machine vary by execution.

.. code-block:: python

   >>> import neal
   >>> solver = neal.SimulatedAnnealingSampler()
   >>> response = solver.sample_ising({'a': -0.5, 'b': 1.0}, {('a', 'b'): -1}, num_reads=2)
   >>> response.data_vectors['energy']       # doctest: +SKIP
   array([-1.5, -0.5])
